"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CIQClient = void 0;
const axios_1 = __importDefault(require("axios"));
const https_1 = __importDefault(require("https"));
const mime_types_1 = __importDefault(require("mime-types"));
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const utils_1 = require("@ninebit/ciq/dist/src/utils");
// process.env.NODE_TLS_REJECT_UNAUTHORIZED = '0';
const agent = new https_1.default.Agent({
    rejectUnauthorized: false,
});
class CIQClient {
    constructor(apiKey, baseUrl = CIQClient.CIQ_HOST) {
        if (!apiKey)
            throw new Error('API key is required');
        this.apiKey = apiKey;
        this.baseUrl = baseUrl;
        this.http = axios_1.default.create({
            baseURL: this.baseUrl,
            headers: {
                'X-API-Key': this.apiKey,
                'Content-Type': 'application/json',
            },
            httpsAgent: agent,
        });
    }
    /**
     * Trigger a new workflow execution
     */
    async triggerWorkflow(payload) {
        try {
            const response = await this.http.post('/workflow-service/trigger_workflow', payload);
            return response.data.content;
        }
        catch (error) {
            this.handleError(error, 'triggerWorkflow');
        }
    }
    /**
     * Get the status and result of a running workflow
     */
    async getWorkflowStatus(wfId) {
        try {
            const response = await this.http.get(`/workflow-service/rt/workflows/${wfId}`);
            return response.data;
        }
        catch (error) {
            this.handleError(error, 'getWorkflowStatus');
        }
    }
    handleError(error, context) {
        const msg = `[CIQClient:${context}] ${(error === null || error === void 0 ? void 0 : error.message) || 'Unknown error'}`;
        console.error(msg);
        if (axios_1.default.isAxiosError(error) && error.response) {
            console.error('Response:', error.response.data);
        }
        throw error;
    }
    /**
     * Polls for completion of a running workflow
     */
    async waitForCompletion(wfId, intervalMs = 2000, onComplete) {
        return new Promise(async (resolve, reject) => {
            const poll = async () => {
                var _a;
                try {
                    const status = await this.getWorkflowStatus(wfId);
                    const currentState = (_a = status === null || status === void 0 ? void 0 : status.content) === null || _a === void 0 ? void 0 : _a.status;
                    if (currentState === 'success') {
                        console.info(`Wofkflow ${wfId} state: ${currentState}`);
                        if (onComplete)
                            onComplete('', status.result);
                        return resolve(status.result);
                    }
                    else if (currentState === 'FAILED' || currentState === 'error') {
                        console.error(`Wofkflow ${wfId} state: ${currentState}`);
                        if (onComplete)
                            onComplete('Wofkflow failed');
                        return reject('Wofkflow failed');
                    }
                    else {
                        console.info(`[waitForCompletion] Wofkflow ${wfId} state: ${currentState}`);
                        setTimeout(poll, intervalMs);
                    }
                }
                catch (err) {
                    console.error(`[waitForCompletion] Error while polling status ${wfId} : ${err}`);
                    return reject(err);
                }
            };
            poll();
        });
    }
    async ingestFile(file, associatedFileName, callback) {
        try {
            let filename;
            if (typeof file === 'string') {
                filename = file;
            }
            else {
                filename = associatedFileName || 'unknown';
            }
            const objectName = path_1.default.basename(filename);
            const contentType = mime_types_1.default.lookup(filename) || 'application/octet-stream';
            // Step 1: Request pre-signed URL from backend
            const presignedResponse = await this.http.post('/workflow-service/generate-presigned-url', {
                object_name: objectName,
                content_type: contentType,
            });
            const presignedUrl = presignedResponse.data.url;
            // Step 2: Upload file to MinIO using PUT
            let data;
            // if (typeof file === 'string') {
            data = fs_1.default.readFileSync(file);
            // } else {
            //   if (file.seek) file.seek(0); // optional; only if custom object supports it
            //   data = await file.arrayBuffer ? Buffer.from(await file.arrayBuffer()) : Buffer.from(await file.read());
            // }
            const uploadResponse = await axios_1.default.put(presignedUrl, data, {
                headers: {
                    'Content-Type': contentType,
                },
                httpsAgent: agent,
            });
            if (uploadResponse.status === 200) {
                console.info('Success: ingestFile');
                // return true;
            }
            else {
                console.error(`Error: ingestFile: ${uploadResponse.status} - ${uploadResponse.statusText}`);
                return false;
            }
            // Step 3: Trigger workflow
            const workspace = this.http.defaults.headers['X-API-Key'];
            const payload = {
                workflow: 'rag-consumer',
                file_path: objectName,
                workspace: workspace,
            };
            const wfId = await this.triggerWorkflow(payload);
            await this.waitForCompletion(wfId);
            if (callback)
                callback({
                    run_id: wfId,
                    workspace: workspace,
                });
        }
        catch (error) {
            console.error(`Error: triggerWorkflow: ${(0, utils_1.formatError)(error)}}`);
            throw new Error('Error: triggerWorkflow');
        }
    }
    async ragQuery(query, euclideanThreshold = 0.9, topK = 6, callback) {
        const workspace = this.http.defaults.headers['X-API-Key'];
        const payload = {
            workflow: 'rag-query',
            rag_query: query,
            workspace: workspace,
            euclidean_threshold: euclideanThreshold,
            top_k: topK,
        };
        try {
            const wfId = await this.triggerWorkflow(payload);
            const response = await this.waitForCompletion(wfId);
            console.info('Success: ragQuery');
            if (callback) {
                callback('', response);
            }
            else {
                return response;
            }
        }
        catch (ex) {
            console.error(`Error: ragQuery: ${(0, utils_1.formatError)(ex)}}`);
            if (callback) {
                callback((0, utils_1.formatError)(ex));
            }
            else {
                throw new Error('Error: ragQuery');
            }
        }
    }
}
exports.CIQClient = CIQClient;
CIQClient.CIQ_HOST = 'https://datahub.ninebit.in';
